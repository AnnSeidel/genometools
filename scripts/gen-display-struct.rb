#!/usr/bin/env ruby

def keywords(display_options)
  kws = Array.new()
  idx = 0
  display_options.each do |arg,helpline|
    incolumn = if helpline.match(/^display /) then "true" else "false" end
    kws.push([arg,idx,incolumn])
    idx += 1
  end
  return kws
end

def indent(longest,arg)
  return " " * (longest - arg.length + 1)
end

def format(longest,helpline)
  len = longest + 3
  out = Array.new()
  helpline.split(/\s/).each do |w|
    if len + w.length <= 58
      out.push(w)
      len += w.length
    else
      out.push("\\n\"\n" + " " * 9 + "\"" + " " * (longest+2) + w)
      len = longest + 1 + w.length
    end
  end
  return out.join(" ")
end

class String
  def dot2us
    return self.gsub(/\./,"_")
  end
  def format_enum_value
    return "Gt_" + self.dot2us.capitalize + "_display"
  end
end

# The following help line defines which keywords can be used as arguments
#  to option -outfmt. Each keyword follows a newline and ends with a :. This
#  is exploited by generating the list of possible keyword for
#  checking the -outfmt argument list generated by
#  gt_se_help2display_strings. The list of keywords must correspond
#  to the type above.

display_options = [
  ["alignment",   "show alignment (possibly followed by =<number> to " +
                  "specify width of alignment columns)"],
  ["seed_in_algn","mark the seed in alignment"],
  ["polinfo",     "add polishing information for shown alignment"],
  ["failed_seed", "show the coordinates of a seed extension, which does not " +
                  "satisfy the filter conditions"],
  ["fstperquery", "output only the first found match per query"],
  ["cigar",       "display cigar string representing alignment"],
  ["s.len",       "display length of match on subject sequence"],
  ["s.seqnum",    "display sequence number of subject sequence"],
  ["s.desc",      "display sequence description of subject sequence"],
  ["s.start",     "display start position of match on subject sequence"],
  ["strand",      "display strand of match"],
  ["q.len",       "display length of match on query sequence"],
  ["q.seqnum",    "display sequence number of query sequence"],
  ["q.desc",      "display sequence description of query sequence"],
  ["q.start",     "display start position of match on query sequence"],
  ["score",       "display score of match"],
  ["editdist",    "display unit edit distance"],
  ["identity",    "display percent identity of match"],
  ["seed.len",    "display length seed of the match"],
  ["seed.s.start","display start position of seed in subject"],
  ["seed.q.start","display start position of seed in query"],
  ["s.seqlen",    "display length of subject sequence in which match occurs"],
  ["q.seqlen",    "display length of query sequence in which match occurs"],
  ["evalue",      "display evalue"],
  ["bitscore",    "display bit score"]
]

display_options.each do |value|
  if value.length != 2 or value[0].match(/\s/)
    STDERR.puts "#{$0}: #{value} is incorrect"
    exit 1
  end
end

outfilename = "src/match/se-display.inc"
begin
  fpout = File.new(outfilename,"w")
rescue => err
  STDERR.puts "#{$0}: cannot create file #{outfilename}"
  exit 1
end

fpout.puts "/* This file was generated by #{$0}, do NOT edit. */"
fpout.puts <<'EOF'
typedef struct
{
  const char *name;
  int rank;
  bool incolumn;
} GtSEdisplayStruct;

struct GtSeedExtendDisplayFlag
{
  unsigned int flags;
  bool a_seedpos_relative, b_seedpos_relative;
  GtUword alignmentwidth;
};

static GtSEdisplayStruct gt_display_arguments_table[] =
{
EOF

kws = keywords(display_options)

fpout.puts kws.sort {|a,b| a[0] <=> b[0]}.
         map{|s,idx,f| "  {\"#{s}\", #{idx}, #{f}}"}.join(",\n")

fpout.puts <<EOF
};

#define GT_DISPLAY_LARGEST_FLAG #{kws.length-1}

const char *gt_querymatch_display_help(void)
{
  return "specify what information about the matches to display\\n\"
EOF

longest = 0
display_options.each do |arg,helpline|
  if longest < arg.length
    longest = arg.length
  end
end

display_options.each do |arg,helpline|
  fpout.puts " " * 9 + "\"#{arg}:#{indent(longest,arg)}" +
       "#{format(longest,helpline)}\\n\""
end

fpout.puts <<'EOF'
;
}

static unsigned int gt_display_mask(int shift)
{
  return 1U << shift;
}

static bool gt_querymatch_display_on(const GtSeedExtendDisplayFlag
                                       *display_flag,
                                     GtSeedExtendDisplay_enum display)
{
  gt_assert((int) display <= GT_DISPLAY_LARGEST_FLAG);
  return (display_flag != NULL &&
          (display_flag->flags & gt_display_mask(display))) ? true : false;
}
EOF

display_options.each do |arg,helpline|
  if arg == "alignment"
    next
  end
  fpout.puts <<EOF

bool gt_querymatch_#{arg.dot2us}_display(const GtSeedExtendDisplayFlag
                                        *display_flag)
{
  return gt_querymatch_display_on(display_flag,#{arg.format_enum_value});
}
EOF
end

fpout.puts <<'EOF'
GtStr *gt_querymatch_column_header(const GtSeedExtendDisplayFlag *display_flag)
{
  GtStr *str = gt_str_new();
  bool firstelem = true;
EOF

display_options.each do |arg,helpline|
  if not helpline.match(/^display /)
    next
  end
fpout.puts <<EOF
  if (gt_querymatch_#{arg.dot2us}_display(display_flag))
  {
    if (!firstelem)
    {
      gt_str_append_cstr(str,", #{arg}");
    } else
    {
      gt_str_append_cstr(str,"#{arg}");
      firstelem = false;
    }
  }
EOF
end

fpout.puts "  return str;"
fpout.puts "}"

fpout.close_write

outfilename = "src/match/se-display-fwd.inc"
begin
  fpout = File.new(outfilename,"w")
rescue => err
  STDERR.puts "#{$0}: cannot create file #{outfilename}"
  exit 1
end

fpout.puts "/* This file was generated by #{$0}, do NOT edit. */"
fpout.puts "typedef enum\n{"

fpout.puts kws.map{|s,idx,f| " #{s.format_enum_value}"}.join(",\n")

fpout.puts "} GtSeedExtendDisplay_enum;"

display_options.each do |arg,helpline|
  if arg != "alignment"
  fpout.puts <<EOF
bool gt_querymatch_#{arg.dot2us}_display(const GtSeedExtendDisplayFlag
                                          *display_flag);
EOF
  end
end
